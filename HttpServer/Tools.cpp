#include "Tools.h"
#include "Log.h"
#include "MysqlConnectionPool.h"

// Timer 类的实现
Timer::Timer()
{
    start = std::chrono::high_resolution_clock::now();
}

Timer::~Timer()
{
    end = std::chrono::high_resolution_clock::now();
    duration = end - start;

    float ms = duration.count() * 1000.0f;
    std::cout << "Timer took" << ms << "ms " << std::endl;
}

// DataValidator 静态成员变量定义
const std::regex DataValidator::EMAIL_REGEX(R"(^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$)");
const std::regex DataValidator::PHONE_REGEX(R"(^1[3-9]\d{9}$)"); // 中国手机号
const std::regex DataValidator::DATE_REGEX(R"(^\d{4}-\d{2}-\d{2}$)");
const std::regex DataValidator::PASSWORD_REGEX(R"(^[a-zA-Z0-9!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]{8,}$)");

// DataValidator 公共方法实现
bool DataValidator::isValidEmail(const std::string& email) {
    return std::regex_match(email, EMAIL_REGEX);
}

bool DataValidator::isValidPhone(const std::string& phone) {
    return std::regex_match(phone, PHONE_REGEX);
}

bool DataValidator::isValidDate(const std::string& date) {
    // 先用正则验证基本格式
    if (!std::regex_match(date, DATE_REGEX)) {
        return false;
    }

    // 使用sscanf安全解析日期
    int year, month, day;
    if (sscanf(date.c_str(), "%d-%d-%d", &year, &month, &day) != 3) {
        return false;
    }

    // 进一步验证日期有效性
    return isValidDateValues(year, month, day);
}

bool DataValidator::isValidPassword(const std::string& password) {
    if (password.length() < 8) {
        return false; // 密码长度至少8位
    }
    return std::regex_match(password, PASSWORD_REGEX);
}

bool DataValidator::validateAll(const std::string& birthday, const std::string& email,
    const std::string& phone, const std::string& password) {
    return isValidDate(birthday) &&
        isValidEmail(email) &&
        isValidPhone(phone) &&
        isValidPassword(password);
}

bool DataValidator::isValidSemester(const std::string& semester)
{
    // 检查长度
    if (semester.length() != 7)
        return false;

    // 检查前两个字符必须是"20"
    if (semester[0] != '2' || semester[1] != '0')
        return false;

    // 检查第3、4个字符必须是数字
    if (!std::isdigit(semester[2]) || !std::isdigit(semester[3]))
        return false;

	static const std::string spring = GetUTF8ForDatabase(L"春");
	static const std::string autumn = GetUTF8ForDatabase(L"秋");
    // 检查最后一个字符必须是'春'或'秋'
    std::string_view t(semester.substr(4));
    if (t != spring && t != autumn)
        return false;

    return true;
}

bool DataValidator::isUserExists(uint32_t user_id, const std::string& password, const std::string& role)
{
    try {
        // 获取 users 表
        // mysqlx::Session sess = MySQLConnectionPool::Instance().GetSession();
        auto sess = MysqlConnectionPool::Instance().GetSession();
        auto users = sess.getSchema("scut_sims").getTable("users");

        // 构建查询条件 - 使用主键(user_id, role)和密码进行匹配
        auto result = users.select("user_id")
            .where("user_id = :uid AND password = :pwd AND role = :r")
            .bind("uid", user_id)
            .bind("pwd", password)
            .bind("r", role)  // 只需要检查是否存在，限制返回1条记录
            .execute();
        sess.close();
        // 检查是否有结果
        return result.count() > 0;
    }
    catch (const mysqlx::Error& err) {
        LOG_DEBUG("Database Error: " << err.what());
        return false;
    }
}

// DataValidator 私有辅助方法实现
bool DataValidator::isValidDateValues(int year, int month, int day) {
    // 检查基本范围
    if (year < 1900 || year > 2100) return false;
    if (month < 1 || month > 12) return false;
    if (day < 1 || day > 31) return false;

    // 各月份天数
    int daysInMonth[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    // 闰年处理
    if (month == 2 && isLeapYear(year)) {
        daysInMonth[1] = 29;
    }

    return day <= daysInMonth[month - 1];
}

bool DataValidator::isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}