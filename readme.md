## 优化点

 Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass

### **HTTP 缓存技术**

对于⼀些具有重复性的 HTTP 请求，⽐如每次请求得到的数据都⼀样的，我们可以把这对 「请求-响应」的数据都缓存在本地

**强缓存**指的是只要浏览器判断缓存没有过期，则直接使⽤浏览器的本地缓存，决定是否使⽤ 缓存的主动性在于浏览器这边。
Cache-Control ， 是⼀个相对时间； Expires ，是⼀个绝对时间；

**什么是协商缓存？**  当我们在浏览器使⽤开发者⼯具的时候，你可能会看到过某些请求的响应码是  304 ，这个是 告诉浏览器可以使⽤本地缓存的资源，通常这种通过服务端告知客户端是否可以使⽤缓存的 ⽅式被称为协商缓存

**第⼀种**：请求头部中的  If-Modified-Since 字段与响应头部中的  Last-Modified 字段实现**第⼆种**：请求头部中的  If-None-Match 字段与响应头部中的  ETag 字段

这两种机制的核心思想是：

- 客户端有资源的缓存副本
- 在使用缓存前，先向服务器"确认"资源是否仍然有效
- 如果有效，服务器返回`304 Not Modified`，客户端使用缓存
- 如果无效，服务器返回`200 OK`和新资源

第⼀种实现⽅式是基于时间实现的，第⼆种实现⽅式是基于⼀个唯⼀标识实现的，相对来说 后者可以更加准确地判断⽂件内容是否被修改，避免由于时间篡改导致的不可靠问题。

## Cookie

对于⽆状态的问题，解法⽅案有很多种，其中⽐较简单的⽅式⽤ Cookie 技术。 Cookie 通过在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态。

**明文传输&不安全**

可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL/TLS 层，使得在安全 上达到了极致。

**公钥加密，私钥解密。**这个⽬的是为了保证内容传输的安全，因为被公钥加密的内容，其他⼈是⽆法解密的，只有持有私钥的⼈，才能解密出实际的内容； 
**私钥加密，公钥解密。**这个⽬的是为了保证消息不会被冒充，因为私钥是不可泄露的，如 果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的⼈发送 的。**可以被窃取，只能验证身份**

⾮对称加密的⽤途主要在于**通过「私钥加密，公钥解密」**的⽅式，来确认消息的身份，即数字签名。不过私钥加密内容不是内容本身，⽽是对 内容的哈希值加密。

<img src="Z:\电子书\操作系统\mages\image-20251011150945505.png" alt="image-20251011150945505" style="zoom: 50%;" />

**数字证书**

前⾯我们知道： 可以通过哈希算法来保证消息的完整性； 可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的⼀⽅发送的）；
还缺少身份验证的环节，万⼀**公钥**是被伪造的呢？

所以你爸把他的公钥注册到警察局，警察局⽤他们⾃⼰的私钥对 你⽗亲的公钥做了个数字签名，然后把你爸爸的「个⼈信息 + 公钥 + 数字签名」打包成⼀个 **数字证书，也就是说这个数字证书包含你爸爸的公钥。**

拿到了数字证书后，⾸先会去警察局验证这个数字证书是否合法，因为数字证书⾥有警 察局的数字签名，警察局要验证证书合法性的时候，⽤⾃⼰的公钥解密，如果能解密成功， 就说明这个数字证书是在警察局注册过的，就认为该数字证书是合法的，然后就会把数字证书⾥头的公钥（你爸爸的）给到⽼师。

正是通过了⼀个权威的机构来证明你爸爸的身份，所以你的伪造公私钥这个⼩伎俩就没⽤ 了。 在计算机⾥，这个权威的机构就是 **CA （数字证书认证机构）**，将服务器公钥放在数字证书 （由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

![image-20251011152048695](Z:\电子书\操作系统\mages\image-20251011152048695.png)



## HTTP1.1性能

HTTP/1.1 提出了⻓连接的通信⽅式，也叫持久连接。
HTTP/1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。
但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应。
如果服务端在处理 A 请求时耗时⽐较⻓，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。 所以，**HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。**

**实际上 HTTP/1.1 管道化技术不是默认开启**，⽽且浏览器基本都没有⽀持，所以后⾯所有⽂章 讨论 HTTP/1.1 都是建⽴在没有使⽤管道化的前提。

**队头阻塞**
<img src="Z:\电子书\操作系统\mages\image-20251011142640308.png" alt="image-20251011142640308" style="zoom:50%;" />

总之 HTTP/1.1 的性能⼀般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。

## HTTPS 如何建立连接

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。 
- 双⽅协商⽣产「会话秘钥」。 
- 双⽅采⽤「会话秘钥」进⾏加密通信。

 前两步也就是 SSL/TLS 的建⽴过程，也就是 TLS 握⼿阶段。

1. ClientHello
   客户端支持的TLS协议版本
   随机数
   客户端支持的密码套件列表，如RSA
2.  SeverHello



## HTTPS 的应⽤数据是如何保证完整性的？

TLS 在实现上分为握⼿协议和记录协议两层：

-  TLS 握⼿协议就是我们前⾯说的 TLS 四次握⼿的过程，负责协商加密算法和⽣成对称密 钥，后续⽤此密钥来保护应⽤程序数据（即 HTTP 数据）； 
- TLS 记录协议负责保护应⽤程序数据并验证其完整性和来源，所以对 HTTP 数据加密是 使⽤记录协议；

## HTTPS ⼀定安全可靠吗？

客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转 发到了⼀个「中间⼈服务器」，于是客户端是和「中间⼈服务器」完成了 TLS 握⼿，然后这 个「中间⼈服务器」再与真正的服务端完成 TLS 握⼿。

![image-20251012210440117](Z:\电子书\操作系统\mages\image-20251012210440117.png)

### 





## 问题2

### 1. 什么是“跨域”问题？

浏览器出于安全考虑，实施了一种称为 **“同源策略”** 的安全措施。

- **同源**：指的是请求的URL和提供JS代码的网页URL在**协议（http/https）、域名（[domain.com](https://domain.com/)）、端口（8080等）** 三者上完全一致。
- **跨域**：只要协议、域名、端口有任何一项不同，就被认为是“跨域”的。

**举个例子：**

- 你的JS代码运行在 `http://localhost:3000` （由React/Vue开发服务器提供）
- 你的Boost.Beast服务器运行在 `http://localhost:8080`

虽然域名都是 `localhost`，但端口不同（3000 vs 8080），这就构成了**跨域**。

### 2. 浏览器为什么要阻止？

为了防止恶意网站（A网站）的脚本偷偷地向你的银行网站（B网站）发起请求（带着你的Cookies），并窃取返回的敏感数据。

因此，浏览器规定：**一个网页中的JS脚本，默认只能访问“同源”的服务器资源**。对于“跨域”请求，浏览器会实际发出请求，但如果服务器没有明确授权，浏览器会**拦截返回的响应**，不交给你的JS代码。

这就是你遇到的状况：**服务器确实发出了响应，但被浏览器中途拦截了。**

### 3. 如何解决？—— CORS

CORS是一种机制，它允许服务器**明确地告诉浏览器**：“我允许来自某个域的客户端请求我的资源”。

实现CORS的方式是：服务器需要在HTTP响应头中添加一些特定的字段。

**最重要的几个响应头是：**

- `Access-Control-Allow-Origin`: 指定允许访问资源的源（域）。
  - `Access-Control-Allow-Origin: http://localhost:3000` （允许特定源）
  - `Access-Control-Allow-Origin: *` （允许所有源，**注意：在生产环境中慎用，会带来安全风险**）
- `Access-Control-Allow-Methods`: 指定允许的HTTP方法（如 `GET, POST, PUT, DELETE`）。
- `Access-Control-Allow-Headers`: 指定允许客户端携带的额外头信息（如 `Content-Type, Authorization`）。



