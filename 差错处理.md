**工厂模式 (Factory Pattern)**
**建议**：为不同类型的Handler创建工厂

简单工厂模式

<img src="Z:\电子书\操作系统\mages\image-20220831172108896.png" alt="img" style="zoom:50%;" />

有一个弊端，它违反了设计模式中的开放-封闭原则
在上面的工厂函数中需要生成三种人造恶魔果实，现在如果想要生成更多，那么就需要在工厂函数的switch语句中添加更多的case，很明显这违背了封闭原则，也就意味着需要基于开放原则来解决这个问题。

<img src="Z:\电子书\操作系统\mages\image-20220831172253762.png" alt="img" style="zoom:50%;" />

抽象工厂模式
<img src="Z:\电子书\操作系统\mages\image-20220903225145620.png" alt="img" style="zoom:50%;" />

**策略模式 (Strategy Pattern)**

**现状**：不同角色的处理逻辑分散在各个Handler中
**建议**：定义统一的处理接口

```cpp
class RequestHandler {
public:
    virtual ~RequestHandler() = default;
    virtual void handleRequest(std::shared_ptr<HttpConnection> con, 
                             const Json::Value& request) = 0;
    virtual bool validateRequest(const Json::Value& request) = 0;
};

class StudentRequestHandler : public RequestHandler {
    // 实现具体的学生请求处理逻辑
};
```

```
RequestHandler (抽象基类)
    ├── StudentRequestHandler (抽象类)
    │   ├── MysqlStudentRequestHandler
    │   ├── OracleStudentRequestHandler
    │   └── MockStudentRequestHandler (用于测试)
    ├── InstructorRequestHandler (抽象类)
    │   ├── MysqlInstructorRequestHandler
    │   └── OracleInstructorRequestHandler
    └── AdminRequestHandler (抽象类)
        ├── MysqlAdminRequestHandler
        └── OracleAdminRequestHandler
```

**建造者模式 (Builder Pattern)**
为复杂的JSON响应构建使用建造者

```cpp
class ResponseBuilder {
private:
    Json::Value root_;
    
public:
    ResponseBuilder& setResult(bool result) {
        root_["result"] = result;
        return *this;
    }
    
    ResponseBuilder& addData(const std::string& key, const Json::Value& value) {
        root_[key] = value;
        return *this;
    }
    
    ResponseBuilder& setError(const std::string& message) {
        root_["error"] = message;
        return *this;
    }
    
    std::string build() {
        Json::StreamWriterBuilder writer;
        return Json::writeString(writer, root_);
    }
};

// 使用示例
void SomeHandler::someMethod(std::shared_ptr<HttpConnection> con) {
    auto response = ResponseBuilder()
        .setResult(true)
        .addData("user_id", 12345)
        .addData("name", "John Doe")
        .build();
    
    beast::ostream(con->GetResponse().body()) << response;
}
```

**又名生成器模式**
化繁为简，逐个击破。也就是分步骤创建复杂的对象，并且允许使用相同的代码生成不同类型和形式的对象，他说这种模式叫做生成器模式（也叫建造者模式）

<img src="Z:\电子书\操作系统\mages\image-20220903072647127.png" alt="img" style="zoom:50%;" />

**模板方法模式**
模板方法模式就是在基类中定义一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。说的再直白一些就是先定义一个基类，在基类中把与需求相关的所有操作函数全部作为虚函数定义出来，然后在这个基类的各个子类中重写父类的虚函数，这样子类基于父类的架构使自己有了和其他兄弟类不一样的行为。模板方法这种设计模式是对多态的典型应用。

![img](Z:\电子书\操作系统\mages\image-20230219164527089.png)

**装饰器模式 (Decorator Pattern)**
**建议**：为请求处理添加额外的功能

```cpp
class HandlerDecorator : public RequestHandler {
protected:
    std::unique_ptr<RequestHandler> wrapped_handler_;
    
public:
    HandlerDecorator(std::unique_ptr<RequestHandler> handler) 
        : wrapped_handler_(std::move(handler)) {}
        
    void handleRequest(std::shared_ptr<HttpConnection> con, 
                      const Json::Value& request) override {
        wrapped_handler_->handleRequest(con, request);
    }
};

class LoggingHandler : public HandlerDecorator {
public:
    using HandlerDecorator::HandlerDecorator;
    
    void handleRequest(std::shared_ptr<HttpConnection> con, 
                      const Json::Value& request) override {
        LOG_INFO("Handling request: " << request.toStyledString());
        wrapped_handler_->handleRequest(con, request);
        LOG_INFO("Request handled successfully");
    }
};

class ValidationHandler : public HandlerDecorator {
public:
    using HandlerDecorator::HandlerDecorator;
    
    void handleRequest(std::shared_ptr<HttpConnection> con, 
                      const Json::Value& request) override {
        if (!validateRequest(request)) {
            // 返回验证错误
            return;
        }
        wrapped_handler_->handleRequest(con, request);
    }
};
```

![image-20251013093700469](Z:\电子书\操作系统\mages\image-20251013093700469.png)



**1.登陆**
user_id, password, role
查询数据库，存在则成功，否则简单返回失败

### 学生

**2.请求可选课程**
浏览所有可选课程 ( student id )
1.选课时间在 section 的 deadline 之前
2.选课人数 < max_capacity
3.先修课已经通过
4.该课未被选过，或者未及格 
5.时间冲突交给cpp
6.学院这个条件允许：

- 本学院的所有课程
- 跨学院的通识必修课（'General Required'）和全校任选课（'University Elective'）

**3.提交选课申请** 已加

改正了之后
![image-20251008153240095](Z:\电子书\操作系统\mages\image-20251008153240095.png)

错误1. 时间冲突
用三维bool数组检测20周，7天，8节课 timetable **[22] [8] [9]**
先读取该学生的三维课表

```mysql
SELECT 
	s.start_week,
	s.end_week,
	s.time_slot
FROM enrollments e
JOIN sections s USING (section_id)
WHERE e.student_id = 1 AND 
	e.status = 'Enrolling';
```

![image-20251008150950343](Z:\电子书\操作系统\mages\image-20251008150950343.png)

错误2. 人数冲突

错误3. 超过选课时间

**4. 学生退课** 无

**5. 查看学生课表**
semester=2025春 学期格式错误？已加

**6. 查询学生成绩**

**7. 查gpa**

**8. 个人信息查询**

**9. 个人信息修改** 已加

```
  birthday: "2005-06-27",
  email: "baobaobus@gmail.com",
  phone: "18923108045",
  password: "aasfaasfdasff666"
```

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <string>
#include <regex>
#include <sstream>
#include <vector>
#include <cstdio>

class DataValidator {
private:
    // 正则表达式模式
    static const std::regex EMAIL_REGEX;
    static const std::regex PHONE_REGEX;
    static const std::regex DATE_REGEX;
    static const std::regex PASSWORD_REGEX;

public:
    // 验证邮箱格式
    static bool isValidEmail(const std::string& email) {
        return std::regex_match(email, EMAIL_REGEX);
    }

    // 验证手机号格式 (中国手机号)
    static bool isValidPhone(const std::string& phone) {
        return std::regex_match(phone, PHONE_REGEX);
    }

    // 验证日期格式 (YYYY-MM-DD)
    static bool isValidDate(const std::string& date) {
        // 先用正则验证基本格式
        if (!std::regex_match(date, DATE_REGEX)) {
            return false;
        }

        // 使用sscanf安全解析日期
        int year, month, day;
        if (sscanf(date.c_str(), "%d-%d-%d", &year, &month, &day) != 3) {
            return false;
        }

        // 进一步验证日期有效性
        return isValidDateValues(year, month, day);
    }

    // 验证密码强度
    static bool isValidPassword(const std::string& password) {
        if (password.length() < 8) {
            return false; // 密码长度至少8位
        }
        return std::regex_match(password, PASSWORD_REGEX);
    }

    // 验证所有字段
    static bool validateAll(const std::string& birthday, const std::string& email,
        const std::string& phone, const std::string& password) {
        return isValidDate(birthday) &&
            isValidEmail(email) &&
            isValidPhone(phone) &&
            isValidPassword(password);
    }

private:
    // 验证日期值的有效性
    static bool isValidDateValues(int year, int month, int day) {
        // 检查基本范围
        if (year < 1900 || year > 2100) return false;
        if (month < 1 || month > 12) return false;
        if (day < 1 || day > 31) return false;

        // 各月份天数
        int daysInMonth[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

        // 闰年处理
        if (month == 2 && isLeapYear(year)) {
            daysInMonth[1] = 29;
        }

        return day <= daysInMonth[month - 1];
    }

    static bool isLeapYear(int year) {
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    }
};

// 初始化静态正则表达式成员
const std::regex DataValidator::EMAIL_REGEX(R"(^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$)");
const std::regex DataValidator::PHONE_REGEX(R"(^1[3-9]\d{9}$)"); // 中国手机号
const std::regex DataValidator::DATE_REGEX(R"(^\d{4}-\d{2}-\d{2}$)");
const std::regex DataValidator::PASSWORD_REGEX(R"(^[a-zA-Z0-9!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]{8,}$)");

// 使用示例
int main() {
    std::string birthday = "2005-06-27";
    std::string email = "baobaobus@gmail.com";
    std::string phone = "18923108045";
    std::string password = "aasfaasfdasff666";

    // 逐个验证
    std::cout << "生日验证: " << (DataValidator::isValidDate(birthday) ? "通过" : "失败") << std::endl;
    std::cout << "邮箱验证: " << (DataValidator::isValidEmail(email) ? "通过" : "失败") << std::endl;
    std::cout << "手机号验证: " << (DataValidator::isValidPhone(phone) ? "通过" : "失败") << std::endl;
    std::cout << "密码验证: " << (DataValidator::isValidPassword(password) ? "通过" : "失败") << std::endl;

    // 整体验证
    if (DataValidator::validateAll(birthday, email, phone, password)) {
        std::cout << "所有数据格式正确!" << std::endl;
    }
    else {
        std::cout << "存在格式错误的数据!" << std::endl;
    }

    // 测试一些边界情况
    std::cout << "\n测试边界情况:" << std::endl;
    std::cout << "无效日期(2005-13-27): " << DataValidator::isValidDate("2005-13-27") << std::endl;
    std::cout << "无效邮箱(baobaobus): " << DataValidator::isValidEmail("baobaobus") << std::endl;
    std::cout << "无效手机号(123456): " << DataValidator::isValidPhone("123456") << std::endl;
    std::cout << "短密码(123): " << DataValidator::isValidPassword("123") << std::endl;

    return 0;
}
```



### 教师

**1. 教授查看课表**
semester=2025春 已写

**2.老师所教的课程中所有学生的成绩查看**
没录入返回-1

**3.录入成绩(id在2中已知)**

**4. 个人信息**

**5. 个人信息修改**（复用学生代码）已加

```
college: "计算机工程",
email: "baobaobus@gmail.com",
phone: "18923108045",
password: "aasfaasfdasff666"
```

### 管理员

**1.获得某种角色的所有账号信息**
role=student 错误

**2.删除某些账号** 已加
role错误，user_id 一般不会出错

**3.增加某个账号** (改动传major_id) 已加
role （student，teacher）错误
name 过长
gender （男/女）错误
grade 大小(2000-2100)
老师 name 过长
college_id

**4.获取某学期所有课程**
?semester=2025春 ‘2025春’格式错误

**5.删除某些课程**
只能删除当前学期的课程，在cpp中判断

**6.增加课程**
6.1 旧course
semester ’2025春‘格式错误
type 格式错误，general required，major required，major elective， university elective， practical
schedule {day, time} 格式错误
max_capacity 太小
startWeek 和 endWeek （1-20）
location 限制格式 A?-??? or B?-??? ?是数字

6.2
和上面相比多了
college_id
course_name 长度限制
credit 只能是正整数，且<=7
type 格式错误，general required，major required，major elective， university elective， practical

**7.改变课程的信息**
schedule {day, time} 格式错误
startWeek 和 endWeek （1-20）

**8. 获取课程的成绩分布**

student_id=5484 id不存在
semester=2025春 格式错误

teacher_id=546 教授id不存在
semester=2025春 格式错误

**11.获取所有的学院信息**

**12.获取某个学院的所有课程信息**

**13.获取某个学院的所有老师信息**

